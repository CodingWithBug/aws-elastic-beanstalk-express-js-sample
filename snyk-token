pipeline {
  agent any

  options {
    // Retain last 20 builds; adjust as needed
    buildDiscarder(logRotator(numToKeepStr: '20'))
    timestamps()
    ansiColor('xterm')
    timeout(time: 60, unit: 'MINUTES')
  }

  environment {
    REGISTRY_URL = 'https://index.docker.io/v1/'
    IMAGE_REPO   = 'panyunpeng/isec6000_assignment2'
    IMAGE_TAG    = "${env.BUILD_NUMBER}"
    REPORT_DIR   = 'reports'
  }

  stages {
    stage('Checkout') {
      steps {
        echo '=== [Checkout] Begin ==='
        checkout scm
        // Use bash explicitly to allow `pipefail`
        sh '''
bash -Eeuo pipefail <<'BASH'
mkdir -p "${REPORT_DIR}/junit" "${REPORT_DIR}/logs" "${REPORT_DIR}/security" "${REPORT_DIR}/docker"
echo "Workspace: $(pwd)" | tee -a "${REPORT_DIR}/logs/checkout.log"
echo "Branch: ${GIT_BRANCH:-unknown}" | tee -a "${REPORT_DIR}/logs/checkout.log"
git log -1 --pretty=oneline | tee -a "${REPORT_DIR}/logs/checkout.log"

# Simple rules file for optional Log Parser plugin (will be used if installed)
cat > "${REPORT_DIR}/logparser-rules.txt" <<'RULES'
error /(^|[^a-zA-Z])(ERR(OR)?|FAIL(ED)?|CRITICAL|FATAL)([^a-zA-Z]|$)/
warning /(^|[^a-zA-Z])(WARN(ING)?|DEPRECATED)([^a-zA-Z]|$)/
RULES
BASH
'''
        script {
          def rev = sh(returnStdout: true, script: "git rev-parse --short HEAD").trim()
          currentBuild.description = "img: ${env.IMAGE_TAG} | git: ${rev}"
        }
        echo '=== [Checkout] Done ==='
      }
    }

    stage('Install & Test (Node 16)') {
      steps {
        echo '=== [Install & Test] Begin ==='
        script {
          docker.image('node:16').inside('-u root') {
            sh '''
bash -Eeuo pipefail <<'BASH'
echo "[Node env]" | tee -a "${REPORT_DIR}/logs/node-env.log"
node -v | tee -a "${REPORT_DIR}/logs/node-env.log"
npm -v  | tee -a "${REPORT_DIR}/logs/node-env.log"

echo "[npm install]" | tee -a "${REPORT_DIR}/logs/npm-install.log"
(npm install --save 2>&1 | tee -a "${REPORT_DIR}/logs/npm-install.log") || true

echo "[npm ci]" | tee -a "${REPORT_DIR}/logs/npm-ci.log"
(npm ci 2>&1 | tee -a "${REPORT_DIR}/logs/npm-ci.log") || true

echo "[npm test]" | tee -a "${REPORT_DIR}/logs/npm-test.log"
export JEST_JUNIT_OUTPUT="${REPORT_DIR}/junit/junit.xml"
(npm test --if-present 2>&1 | tee -a "${REPORT_DIR}/logs/npm-test.log}") || true

test -f "${REPORT_DIR}/junit/junit.xml" \
  && echo "JUnit report generated at ${REPORT_DIR}/junit/junit.xml" \
  || echo "No JUnit file produced by tests."
BASH
'''
          }
        }
        echo '=== [Install & Test] Done ==='
      }
    }

    stage('Security Scan (Snyk, fail on High/Critical)') {
      environment { SNYK_TOKEN = credentials('snyk-token') }
      steps {
        echo '=== [Security Scan] Begin ==='
        script {
          docker.image('node:16').inside('-u root') {
            sh '''
bash -Eeuo pipefail <<'BASH'
echo "[Snyk setup]" | tee -a "${REPORT_DIR}/logs/snyk.log"
npm install -g snyk 2>&1 | tee -a "${REPORT_DIR}/logs/snyk.log"
snyk auth "${SNYK_TOKEN}" 2>&1 | tee -a "${REPORT_DIR}/logs/snyk.log"

echo "[Snyk test JSON]" | tee -a "${REPORT_DIR}/logs/snyk.log"
# Fail build on High/Critical issues; also store machine-readable JSON
bash -o pipefail -c 'snyk test --severity-threshold=high --json \
  | tee "${REPORT_DIR}/security/snyk-report.json"'

echo "[Snyk test SARIF]" | tee -a "${REPORT_DIR}/logs/snyk.log"
# SARIF for dashboards; non-fatal
snyk test --severity-threshold=high \
  --sarif-file-output="${REPORT_DIR}/security/snyk-report.sarif" \
  2>&1 | tee -a "${REPORT_DIR}/logs/snyk.log" || true
BASH
'''
          }
        }
        echo '=== [Security Scan] Done ==='
      }
    }

    stage('Build & Push Docker Image') {
      steps {
        echo '=== [Docker Build & Push] Begin ==='
        script {
          def app = docker.build("${IMAGE_REPO}:${IMAGE_TAG}")
          docker.withRegistry(env.REGISTRY_URL, 'dockerhub-credentials') {
            app.push("${IMAGE_TAG}")
            app.push('latest')
          }
          sh '''
bash -Eeuo pipefail <<'BASH'
docker image inspect "${IMAGE_REPO}:${IMAGE_TAG}" \
  > "${REPORT_DIR}/docker/image-inspect.json"
docker history --no-trunc "${IMAGE_REPO}:${IMAGE_TAG}" \
  > "${REPORT_DIR}/docker/image-history.txt"
BASH
'''
        }
        echo '=== [Docker Build & Push] Done ==='
      }
    }
  }

  post {
    always {
      script {
        // Publish JUnit if present (won't fail if missing)
        junit allowEmptyResults: true, testResults: "${REPORT_DIR}/junit/**/*.xml"
      }

      // Archive everything under reports plus any legacy snyk-report.json
      archiveArtifacts artifacts: """
        ${REPORT_DIR}/**/*,
        snyk-report.json
      """.stripIndent().trim(), allowEmptyArchive: true

      // Try to annotate logs if Log Parser plugin is installed
      script {
        try {
          logParser(
            projectRulePath: "${REPORT_DIR}/logparser-rules.txt",
            useProjectRule: true,
            parseRunningBuild: true,
            showGraphs: true,
            unstableOnWarning: false,
            failBuildOnError: false
          )
        } catch (ignored) {
          echo "Log Parser plugin not installed; skipping annotated console parsing."
        }
      }

      echo "Artifacts archived under '${REPORT_DIR}/'."
    }

    success {
      echo "✅ Build succeeded. Image pushed: ${env.IMAGE_REPO}:${env.IMAGE_TAG}"
    }

    unstable {
      echo "⚠️ Build marked UNSTABLE. Please review test and security results."
    }

    failure {
      echo "❌ Build failed. Check detailed logs in ${env.REPORT_DIR}/logs/"
    }
  }
}
